#create observe event module to monitor if user input select variable to reorder
#if variable selected, update the select input list for value choices of the selected variable
observeEvent(input$reorder_variable, {
choices <- unique(data_prm_combined_plot_rename$data[[input$reorder_variable]])
updateSelectInput(inputId = "reorder_order", choices = sort(choices))
})
#change value of selected variable to the value from user
observeEvent(input$reorder_button, {
reorder_df <- data_prm_combined_plot_rename$data
reorder_df[[input$reorder_variable]] <- factor(reorder_df[[input$reorder_variable]], levels = input$reorder_order)
data_prm_combined_plot_rename$data <- reorder_df
})
#remember variable set for plotting, so can be recovered after making change to dataframe and plotting engine reactively update, reinitialise
plot_var_select_cache <- reactiveValues()
observe({
req(input$y_var,input$x_var, input$col_var,input$shape_var,input$linetype_var,input$facet_var)
plot_var_select_cache$y_var <- input$y_var
plot_var_select_cache$x_var <- input$x_var
plot_var_select_cache$col_var <- input$col_var
plot_var_select_cache$shape_var <- input$shape_var
plot_var_select_cache$shape_var <- input$shape_var
plot_var_select_cache$linetype_var <- input$linetype_var
plot_var_select_cache$facet_var <- input$facet_var
})
#record everytime that the value change, keep only the most recent previous value and current value
observeEvent(input$y_var,{
plot_var_select_cache$y_var <- input$y_var
plot_var_select_cache$x_var <- input$x_var
plot_var_select_cache$col_var <- input$col_var
plot_var_select_cache$shape_var <- input$shape_var
plot_var_select_cache$linetype_var <- input$linetype_var
plot_var_select_cache$facet_var <- input$facet_var
})
observeEvent(input$x_var,{
plot_var_select_cache$y_var <- input$y_var
plot_var_select_cache$x_var <- input$x_var
plot_var_select_cache$col_var <- input$col_var
plot_var_select_cache$shape_var <- input$shape_var
plot_var_select_cache$linetype_var <- input$linetype_var
plot_var_select_cache$facet_var <- input$facet_var
})
observeEvent(input$col_var,{
plot_var_select_cache$y_var <- input$y_var
plot_var_select_cache$x_var <- input$x_var
plot_var_select_cache$col_var <- input$col_var
plot_var_select_cache$shape_var <- input$shape_var
plot_var_select_cache$linetype_var <- input$linetype_var
plot_var_select_cache$facet_var <- input$facet_var
})
observeEvent(input$shape_var,{
plot_var_select_cache$y_var <- input$y_var
plot_var_select_cache$x_var <- input$x_var
plot_var_select_cache$col_var <- input$col_var
plot_var_select_cache$shape_var <- input$shape_var
plot_var_select_cache$linetype_var <- input$linetype_var
plot_var_select_cache$facet_var <- input$facet_var
})
observeEvent(input$facet_var,{
plot_var_select_cache$y_var <- input$y_var
plot_var_select_cache$x_var <- input$x_var
plot_var_select_cache$col_var <- input$col_var
plot_var_select_cache$shape_var <- input$shape_var
plot_var_select_cache$linetype_var <- input$linetype_var
plot_var_select_cache$facet_var <- input$facet_var
})
###set y and x axis range in plot
observeEvent(input$y_var, {
min = min(data_prm_combined_plot_rename$data[[input$y_var]])
max = max(data_prm_combined_plot_rename$data[[input$y_var]])
updateSliderInput(inputId = "y_var_range", min = min, max = max, value = c(min,max))
})
observeEvent(input$x_var, {
min = min(data_prm_combined_plot_rename$data[[input$x_var]])
max = max(data_prm_combined_plot_rename$data[[input$x_var]])
updateSliderInput(inputId = "x_var_range", min = min, max = max, value = c(min,max))
})
#set color palette
custom_palette <- reactive({
default_palette <- c("#999999", "#56B4E9", "#E69F00", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7", "#000000")
#vector of available color choices to form custom palette
color_choice_hex <- c("#000000","#999999", "#56B4E9", "#E69F00", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7","#E41A1C","#A6D854")
names(color_choice_hex) <- c("black","grey", "skyblue","orange","green","yellow","blue","vermillion","purple", "red","lightgreen")
#make palette from custom colors selected from user
if(length(input$col_palette) > 0){
palette <- color_choice_hex[input$col_palette]
}else{
palette <- default_palette
}
unname(palette)
})
#set shape palette
custom_shape <- reactive({
default_shape <- c(16,17,15,18,4,1,2,0,5)
#vector of available shape choices to form custom palette
shape_choice <- c(16,17,15,18,4,1,2,0,5)
names(shape_choice) <- c("circle", "triangle", "rectangle", "diamond", "cross", "hollow_circle", "hollow_triangle", "hollow_rectangle", "hollow_diamond")
#make palette from custom shapes selected from user
if(length(input$shape_palette) > 0){
shape.palette <- shape_choice[input$shape_palette]
}else{
shape.palette <- default_shape
}
unname(as.numeric(shape.palette))
})
#set linetype palette
custom_linetype <- reactive({
default_linetype <- c(1:6)
#vector of available shape choices to form custom palette
linetype_choice <- c(1:6)
names(linetype_choice) <- c("solid", "dashed", "dotted", "dotdash", "longdash", "twodash")
#make palette from custom shapes selected from user
if(length(input$linetype_palette) > 0){
linetype.palette <- linetype_choice[input$linetype_palette]
}else{
linetype.palette <- default_linetype
}
unname(as.numeric(linetype.palette))
})
#set legend direction
legend_direction <- reactive({
if(input$legend_position %in% c("top","bottom")){
"horizontal"
} else{
"vertical"
}
})
ggplot_plugin <- reactive({
withProgress(message = "Plotting", value = 0.7,{
#initial plot according to selected coloring and group variable
if(length(input$shape_var) > 0 & length(input$col_var) > 0 & length(input$linetype_var) > 0){
p <- ggplot(data = data_prm_combined_plot_rename$data, aes(x = .data[[input$x_var]], y = .data[[input$y_var]], group = interaction(.data[[input$shape_var]], .data[[input$col_var]], .data[[input$linetype_var]]), col = .data[[input$col_var]], fill = .data[[input$col_var]], shape = .data[[input$shape_var]], linetype = .data[[input$linetype_var]]))
}
else if(length(input$shape_var) > 0 & length(input$col_var) > 0){
p <- ggplot(data = data_prm_combined_plot_rename$data, aes(x = .data[[input$x_var]], y = .data[[input$y_var]], group = interaction(.data[[input$shape_var]], .data[[input$col_var]]), col = .data[[input$col_var]], fill = .data[[input$col_var]], shape = .data[[input$shape_var]]))
}
else if(length(input$shape_var) > 0 & length(input$linetype_var) > 0){
p <- ggplot(data = data_prm_combined_plot_rename$data, aes(x = .data[[input$x_var]], y = .data[[input$y_var]], group = interaction(.data[[input$shape_var]], .data[[input$linetype_var]]), shape = .data[[input$shape_var]], linetype = .data[[input$linetype_var]]))
}
else if(length(input$col_var) > 0 & length(input$linetype_var) > 0){
p <- ggplot(data = data_prm_combined_plot_rename$data, aes(x = .data[[input$x_var]], y = .data[[input$y_var]], group = interaction(.data[[input$col_var]], .data[[input$linetype_var]]), col = .data[[input$col_var]], fill = .data[[input$col_var]], linetype = .data[[input$linetype_var]]))
}
else if(length(input$col_var) > 0){
p <- ggplot(data = data_prm_combined_plot_rename$data, aes(x = .data[[input$x_var]], y = .data[[input$y_var]], group = .data[[input$col_var]], col = .data[[input$col_var]], fill = .data[[input$col_var]]))
}
else if(length(input$shape_var) > 0){
p <- ggplot(data = data_prm_combined_plot_rename$data, aes(x = .data[[input$x_var]], y = .data[[input$y_var]], group = .data[[input$shape_var]], shape = .data[[input$shape_var]]))
}
else if(length(input$linetype_var) > 0){
p <- ggplot(data = data_prm_combined_plot_rename$data, aes(x = .data[[input$x_var]], y = .data[[input$y_var]], group = .data[[input$linetype_var]], linetype = .data[[input$linetype_var]]))
}
else{
p <- ggplot(data = data_prm_combined_plot_rename$data, aes(x = .data[[input$x_var]], y = .data[[input$y_var]]))
}
#add plot
p <- p +
theme(axis.title = element_text(size = as.numeric(input$font_size_axis_title)),
axis.text = element_text(size = as.numeric(input$font_size_axis_text)),
legend.title = element_blank(),
#legend.title = element_text(size = as.numeric(input$font_size_legend)),
legend.text = element_text(size = as.numeric(input$font_size_legend)),
strip.text = element_text(size = as.numeric(input$font_size_facet)),
plot.title = element_text(size = as.numeric(input$font_size_plot_title)),
legend.position = paste(input$legend_position),
legend.direction = paste(legend_direction()),
panel.background = element_rect(colour = "black", fill = "white"),
plot.background = element_rect(colour = NA, fill = "white"),
axis.line = element_line(colour="black",size=0.1),
axis.ticks = element_line(),
axis.title.x = element_text(vjust = -2.5, face = "bold"),
axis.title.y = element_text(vjust = +2.5, face="bold"),
legend.key = element_rect(colour = NA, fill = NA),
legend.key.size= unit(0.75, "cm"),
strip.background=element_rect(colour="#000000",fill=NA),
plot.margin=unit(c(10,5,5,5),"mm")
) +
scale_color_manual(values=custom_palette()) +
scale_shape_manual(values=custom_shape()) +
scale_linetype_manual(values = custom_linetype())+
guides(color = guide_legend(override.aes = list(size=3)))
#pretty scales for numeric variable
if(is.numeric(data_prm_combined_plot_rename$data[[input$x_var]])){
p <- p +
scale_x_continuous(breaks = breaks_pretty(), limits = c(as.numeric(input$x_var_range[1]),as.numeric(input$x_var_range[2])))
}
if(is.numeric(data_prm_combined_plot_rename$data[[input$y_var]])){
p <- p +
scale_y_continuous(breaks = breaks_pretty(), limits = c(as.numeric(input$y_var_range[1]),as.numeric(input$y_var_range[2])))
}
if(is.Date(data_prm_combined_plot_rename$data[[input$x_var]])){
p <- p +
scale_x_date(breaks = breaks_pretty())
}
if(is.Date(data_prm_combined_plot_rename$data[[input$y_var]])){
p <- p +
scale_y_date(breaks = breaks_pretty())
}
#x axis text angle
if(as.numeric(input$x_axis_label_angle) > 0){
p <- p + theme(axis.text.x = element_text(angle = as.numeric(input$x_axis_label_angle), hjust = 1, vjust = 1))
}
#select facet variable
if(length(input$facet_var) == 1){
p <- p + facet_wrap(~get(input$facet_var[1]))
} else if(length(input$facet_var) == 2){
p <- p + facet_grid(get(input$facet_var[2])~get(input$facet_var[1]))
} else {
p <- p
}
#select plotting elements (geom)
if("point" %in% input$plot_element){
p <- p + geom_point(size = as.numeric(input$point_size), alpha = as.numeric(input$point_transparency))
}
if("line" %in% input$plot_element){
p <- p + geom_line(size = as.numeric(input$line_size))
}
if("linear_trend_error" %in% input$plot_element){
p <- p + geom_smooth(method="lm", se = T, show.legend = FALSE, size = as.numeric(input$line_size))
}
if("linear_trend" %in% input$plot_element & !("linear_trend_error" %in% input$plot_element)){
p <- p + geom_smooth(method="lm", se = F, show.legend = FALSE, size = as.numeric(input$line_size))
}
if("loess_smooth_trend_error" %in% input$plot_element){
p <- p + geom_smooth(method="loess", se = T, show.legend = FALSE, size = as.numeric(input$line_size))
}
if("loess_smooth_trend" %in% input$plot_element & !("loess_smooth_trend_error" %in% input$plot_element)){
p <- p + geom_smooth(method="loess", se = F, show.legend = FALSE, size = as.numeric(input$line_size))
}
if("background_grid" %in% input$plot_element){
p <- p + theme(panel.grid.major = element_line(colour="#f0f0f0"),
panel.grid.minor = element_blank())
}else{
p <- p + theme(panel.grid.major = element_blank())
}
if(length(input$plot_element) == 0){
p <- p
}
#add custom text for axis label
if(nchar(input$y_var_label) > 0){
p <- p + labs(y = paste(input$y_var_label))
}
if(nchar(input$x_var_label) > 0){
p <- p + labs(x = paste(input$x_var_label))
}
if(nchar(input$title_label) > 0){
p <- p + labs(title = paste(input$title_label))
}
print(p)
})
})
#adjust default plot size according to facets
#select facet variable
observeEvent(input$facet_var, {
if(length(input$facet_var) == 1){
if(length(unique(data_prm_combined_plot_rename$data[[input$facet_var[1]]])) == 1){
updateTextInput(session, "export_plot_width", value = "19")
updateTextInput(session,"export_plot_height", value = "12")
}
if(length(unique(data_prm_combined_plot_rename$data[[input$facet_var[1]]])) == 2){
updateTextInput(session, "export_plot_width", value = "29")
updateTextInput(session,"export_plot_height", value = "12")
}
if(length(unique(data_prm_combined_plot_rename$data[[input$facet_var[1]]])) > 2){
updateTextInput(session, "export_plot_width", value = "39")
updateTextInput(session,"export_plot_height", value = "12")
}
if(length(unique(data_prm_combined_plot_rename$data[[input$facet_var[1]]])) > 3){
updateTextInput(session, "export_plot_width", value = "39")
updateTextInput(session,"export_plot_height", value = "23")
}
}
if(length(input$facet_var) == 2){
if(length(unique(data_prm_combined_plot_rename$data[[input$facet_var[1]]])) == 1){
updateTextInput(session,"export_plot_width", value = "19")
}
if(length(unique(data_prm_combined_plot_rename$data[[input$facet_var[1]]])) == 2){
updateTextInput(session,"export_plot_width", value = "29")
}
if(length(unique(data_prm_combined_plot_rename$data[[input$facet_var[1]]])) > 2){
updateTextInput(session,"export_plot_width", value = "39")
}
if(length(unique(data_prm_combined_plot_rename$data[[input$facet_var[2]]])) == 1){
updateTextInput(session,"export_plot_height", value = "12")
}
if(length(unique(data_prm_combined_plot_rename$data[[input$facet_var[2]]])) > 1){
updateTextInput(session,"export_plot_height", value = "23")
}
}
})
#render ggplot display in app
output$ggplot_plugin_display <- renderPlot({
ggplot_plugin()
},width=exprToFunction(as.numeric(input$export_plot_width)*36), height=exprToFunction(as.numeric(input$export_plot_height)*36))
#for downloading ggplot
output$ggplot_plugin_download <- downloadHandler(
filename = function() {paste0("plot.", input$export_plot_format)},
content = function(file) {
ggsave(file, plot = ggplot_plugin(), device = {{input$export_plot_format}} , width = as.numeric({{input$export_plot_width}}), height = as.numeric({{input$export_plot_height}}), units = "cm")
}
)
###### Analysis ####
###create reactive dataset for analyses (take from seasonal data)
data_prm_combined_analysis <- reactiveValues()
observe({data_prm_combined_analysis$data <- data_prm_combined$data})
###time period window analysis
#update window slider input for selecting year range to include in analysis, set min max according to data
observe({
req(input$upload_all_files)
year.start <- min(data_prm_combined_analysis$data[["Year1"]])
year.end <- max(data_prm_combined_analysis$data[["Year1"]])
updateSliderInput(inputId = "time_range", min = year.start, max = year.end, value = c(year.start, year.end))
})
#update window slider input for year, set min max according to data
observe({
req(input$upload_all_files)
year.range <- max(data_prm_combined_analysis$data[["Year1"]]) - min(data_prm_combined_analysis$data[["Year1"]])
updateSliderInput(inputId = "time_period", min = 1, max = year.range)
})
#update variable choice
observe({
choices <- setdiff(colnames(data_prm_combined_analysis$data), c("name","RunNr","Day1","Month1","Year1","DayN","MonthN","YearN","prm.file"))
choices <- setdiff(choices, colnames(upload_prm_combined_renamecol$data))
updateSelectizeInput(inputId = "time_period_variable", choices = sort(choices))
})
#update grouping choice
observe({
group.choices <- setdiff(colnames(data_prm_combined_analysis$data), colnames(upload_data_combined()))
updateSelectizeInput(inputId = "time_period_group", choices = sort(group.choices))
})
#calculate summary in time period selected
data_prm_combined_timeperiod <- reactive({
req(input$upload_all_files)
req(input$time_period_variable)
#cut time into windows
column.select <- c("time.window", input$time_period_variable, input$time_period_group)
column.group <- c(input$time_period_group, "time.window")
#calculate summary
data_prm_combined_analysis$data %>%
filter(Year1 >= input$time_range[1] & Year1 <= input$time_range[2]) %>%
mutate(time.window = cut(Year1,
unique(c(seq(min(Year1), max(Year1), input$time_period),min(Year1), max(Year1))),
include.lowest = TRUE, right = FALSE, dig.lab = 4)) %>%
mutate(time.window = str_replace_all(time.window,"\\[|\\)","")) %>%
separate(time.window, c("start", "end"), sep = ",") %>%
mutate(end = ifelse(str_detect(end, "\\]"), as.numeric(str_replace(end, "\\]",""))+1, end))%>%
mutate(time.window = paste0(start, "-", as.numeric(end)-1)) %>%
select(all_of(column.select)) %>%
group_by(across(all_of(column.group))) %>%
summarise(mean = mean(.data[[input$time_period_variable]]),
SD = sd(.data[[input$time_period_variable]]),
coef.of.variation = SD/mean,
n = n()) %>%
mutate(mean = format(signif(mean, digits = 3)),
SD = format(signif(SD, digits = 3)),
coef.of.variation = format(signif(coef.of.variation, digits = 3))
) %>%
rename_with(~paste0(input$time_period_variable, ".", .x), c(mean, SD, coef.of.variation))
})
#display table
output$data_prm_combined_timeperiod_display <- renderDataTable(data_prm_combined_timeperiod(), options = list(scrollX = TRUE))
#for downloading calculated dataset
output$download_data_prm_combined_timeperiod <- downloadHandler(
filename = "Aquacrop_time_window_analysis.tsv",
content = function(file) {
write_tsv(data_prm_combined_timeperiod(), file)
}
)
###stress, phenological stage analysis
#update grouping choice
observe({
group.choices <- setdiff(colnames(daily_data_prm_combined$data), colnames(upload_daily_data_combined()))
updateSelectizeInput(inputId = "stress_group", choices = sort(group.choices))
})
#calculate summary
daily_data_prm_combined_stress <- reactive({
req(input$upload_all_files)
#selecting variables
if(input$by_phenological == "yes"){
column.group <- c("Year", "Stage", "prm.file.name", input$stress_group)
column.select <- c("Year","Stage", "StExp", "StSto", "StSen", "StTr","prm.file.name", input$stress_group)
}else{
column.group <- c("Year", "prm.file.name", input$stress_group)
column.select <- c("Year", "StExp", "StSto", "StSen", "StTr","prm.file.name", input$stress_group)
}
#calculate summary
daily_data_prm_combined$data %>%
mutate(Stage = as.character(Stage)) %>%
mutate(Stage = case_when(
Stage == "0" ~ "0_before_after_cropping",
Stage == "1" ~ "1_sowing_transplant",
Stage == "2" ~ "2_vegetative",
Stage == "3" ~ "3_flowering",
Stage == "4" ~ "4_yield_ripening",
Stage == "-9" ~ "-9_senescence",
TRUE ~ Stage
)) %>%
select(all_of(column.select)) %>%
group_by(across(all_of(column.group))) %>%
summarise(StExp.duration.days = length(StExp[which(StExp >= as.numeric(input$StExp_threshold))]),
StSto.duration.days = length(StSto[which(StSto >= as.numeric(input$StSto_threshold))]),
StSen.duration.days = length(StSen[which(StSen >= as.numeric(input$StSen_threshold))]),
StTr.duration.days = length(StTr[which(StTr >= as.numeric(input$StTr_threshold))]),
StExp.duration.percent = length(StExp[which(StExp >= as.numeric(input$StExp_threshold))])/length(StExp[which(StExp >= 0)]),
StSto.duration.percent = length(StSto[which(StSto >= as.numeric(input$StSto_threshold))])/length(StSto[which(StSto >= 0)]),
StSen.duration.percent = length(StSen[which(StSen >= as.numeric(input$StSen_threshold))])/length(StSen[which(StSen >= 0)]),
StTr.duration.percent = length(StTr[which(StTr >= as.numeric(input$StTr_threshold))])/length(StTr[which(StTr >= 0)])
) %>%
mutate(StExp.duration.percent = format(signif(StExp.duration.percent*100, digits = 2)) %>% as.numeric(),
StSto.duration.percent = format(signif(StSto.duration.percent*100, digits = 2)) %>% as.numeric(),
StSen.duration.percent = format(signif(StSen.duration.percent*100, digits = 2)) %>% as.numeric(),
StTr.duration.percent = format(signif(StTr.duration.percent*100, digits = 2)) %>% as.numeric()
)
})
#display table
output$daily_data_prm_combined_stress_display <- renderDataTable(daily_data_prm_combined_stress(), options = list(scrollX = TRUE))
#for downloading calculated dataset
output$download_daily_data_prm_combined_stress <- downloadHandler(
filename = "Aquacrop_stress_analysis.tsv",
content = function(file) {
write_tsv(daily_data_prm_combined_stress(), file)
}
)
##append stress duration data to seasonal dataset for plotting and other analyses
observeEvent(input$append_stress_data_button, {
data_prm_combined_analysis$data <- left_join(data_prm_combined_analysis$data %>% select(all_of(setdiff(colnames(data_prm_combined_analysis$data),c("StExp.duration.days", "StSto.duration.days", "StSen.duration.days", "StTr.duration.days", "StExp.duration.percent", "StSto.duration.percent", "StSen.duration.percent", "StTr.duration.percent")))),
daily_data_prm_combined_stress() %>% select("prm.file.name", "Year", "StExp.duration.days", "StSto.duration.days", "StSen.duration.days", "StTr.duration.days", "StExp.duration.percent", "StSto.duration.percent", "StSen.duration.percent", "StTr.duration.percent"),
by = c("prm.file.name" = "prm.file.name", "Year1"="Year"))
updateSelectizeInput(inputId = "plot_mode", selected = "seasonal")
})
observeEvent(input$append_stress_data_button, {
req(data_prm_combined_plot_rename$data)
if(input$plot_mode == "seasonal"){
data_prm_combined_plot_rename$data  <- left_join(data_prm_combined_plot_rename$data %>% select(all_of(setdiff(colnames(data_prm_combined_plot_rename$data),c("StExp.duration.days", "StSto.duration.days", "StSen.duration.days", "StTr.duration.days", "StExp.duration.percent", "StSto.duration.percent", "StSen.duration.percent", "StTr.duration.percent")))),
daily_data_prm_combined_stress() %>% select("prm.file.name", "Year", "StExp.duration.days", "StSto.duration.days", "StSen.duration.days", "StTr.duration.days", "StExp.duration.percent", "StSto.duration.percent", "StSen.duration.percent", "StTr.duration.percent"),
by = c("prm.file.name" = "prm.file.name", "Year1"="Year"))
}
})
######regression
##select data mode daily or seasonal
data_mode_selected_regression <- reactive({
req(input$regression_mode)
req(input$upload_all_files)
if(input$regression_mode == "daily"){
#return data to use
daily_data_prm_combined$data
}else{
#return data to use
data_prm_combined_analysis$data
}
})
observe({
req(input$regression_mode)
req(input$upload_all_files)
if(input$regression_mode == "daily"){
#update choices for variables
axis.choices = unique(colnames(daily_data_prm_combined$data))
updateSelectInput(inputId = "regression_y_variable", choices = sort(axis.choices))
updateSelectInput(inputId = "regression_x_variable", choices = sort(axis.choices))
#update choices for grouping variable
group.choices <- setdiff(colnames(daily_data_prm_combined$data), colnames(upload_daily_data_combined()))
group.choices <- c(group.choices, "Stage")
updateSelectizeInput(inputId = "regression_group", choices = sort(group.choices))
}else{
#update choices for variables
axis.choices = unique(colnames(data_prm_combined_analysis$data))
updateSelectInput(inputId = "regression_y_variable", choices = sort(axis.choices))
updateSelectInput(inputId = "regression_x_variable", choices = sort(axis.choices))
#update choices for grouping variable
group.choices <- setdiff(colnames(data_prm_combined_analysis$data), colnames(upload_data_combined()))
updateSelectizeInput(inputId = "regression_group", choices = sort(group.choices))
}
})
#regression calculation
data_regression <- reactive({
req(input$regression_mode)
req(input$regression_y_variable)
req(input$regression_x_variable)
req(input$upload_all_files)
if(length(input$regression_group) > 0){
column.group <- input$regression_group
column.select <- c(input$regression_y_variable, input$regression_x_variable, input$regression_group)
}else{
column.group <- NULL
column.select <- c(input$regression_y_variable, input$regression_x_variable)
}
data_mode_selected_regression() %>%
select(all_of(column.select)) %>%
group_by(across(all_of(column.group))) %>%
nest() %>%
mutate(model = map(data, function(data){
mod <- lm(data = data, as.formula(paste0("`",input$regression_y_variable,"`","~","`",input$regression_x_variable,"`")))
r.squared <- glance(mod)[["r.squared"]] %>% signif(digits = 3) %>% format()
slope <- tidy(mod)[["estimate"]][[2]] %>% signif(digits = 3) %>% format()
p.value <- tidy(mod)[["p.value"]][[2]] %>% signif(digits = 3) %>% format()
summary <- data.frame(r.squared,slope,p.value)
})) %>%
select(-data) %>%
unnest(model)
})
#output datatable of the regression
output$regression_display <- renderDataTable(datatable(data_regression(),
options = list(scrollX = TRUE)))
#for downloading regresion data
output$download_regression <- downloadHandler(
filename = "Aquacrop_regression.tsv",
content = function(file) {
write_tsv(data_regression(), file)
}
)
}
# Run the application
shinyApp(ui = ui, server = server)
install.packages("reoxygen")
