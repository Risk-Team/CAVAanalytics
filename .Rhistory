default_linetype <- c(1:6)
#vector of available shape choices to form custom palette
linetype_choice <- c(1:6)
names(linetype_choice) <- c("solid", "dashed", "dotted", "dotdash", "longdash", "twodash")
#make palette from custom shapes selected from user
if(length(input$linetype_palette) > 0){
linetype.palette <- linetype_choice[input$linetype_palette]
}else{
linetype.palette <- default_linetype
}
unname(as.numeric(linetype.palette))
})
#set legend direction
legend_direction <- reactive({
if(input$legend_position %in% c("top","bottom")){
"horizontal"
} else{
"vertical"
}
})
ggplot_plugin <- reactive({
withProgress(message = "Plotting", value = 0.7,{
#initial plot according to selected coloring and group variable
if(length(input$shape_var) > 0 & length(input$col_var) > 0 & length(input$linetype_var) > 0){
p <- ggplot(data = data_prm_combined_plot_rename$data, aes(x = .data[[input$x_var]], y = .data[[input$y_var]], group = interaction(.data[[input$shape_var]], .data[[input$col_var]], .data[[input$linetype_var]]), col = .data[[input$col_var]], fill = .data[[input$col_var]], shape = .data[[input$shape_var]], linetype = .data[[input$linetype_var]]))
}
else if(length(input$shape_var) > 0 & length(input$col_var) > 0){
p <- ggplot(data = data_prm_combined_plot_rename$data, aes(x = .data[[input$x_var]], y = .data[[input$y_var]], group = interaction(.data[[input$shape_var]], .data[[input$col_var]]), col = .data[[input$col_var]], fill = .data[[input$col_var]], shape = .data[[input$shape_var]]))
}
else if(length(input$shape_var) > 0 & length(input$linetype_var) > 0){
p <- ggplot(data = data_prm_combined_plot_rename$data, aes(x = .data[[input$x_var]], y = .data[[input$y_var]], group = interaction(.data[[input$shape_var]], .data[[input$linetype_var]]), shape = .data[[input$shape_var]], linetype = .data[[input$linetype_var]]))
}
else if(length(input$col_var) > 0 & length(input$linetype_var) > 0){
p <- ggplot(data = data_prm_combined_plot_rename$data, aes(x = .data[[input$x_var]], y = .data[[input$y_var]], group = interaction(.data[[input$col_var]], .data[[input$linetype_var]]), col = .data[[input$col_var]], fill = .data[[input$col_var]], linetype = .data[[input$linetype_var]]))
}
else if(length(input$col_var) > 0){
p <- ggplot(data = data_prm_combined_plot_rename$data, aes(x = .data[[input$x_var]], y = .data[[input$y_var]], group = .data[[input$col_var]], col = .data[[input$col_var]], fill = .data[[input$col_var]]))
}
else if(length(input$shape_var) > 0){
p <- ggplot(data = data_prm_combined_plot_rename$data, aes(x = .data[[input$x_var]], y = .data[[input$y_var]], group = .data[[input$shape_var]], shape = .data[[input$shape_var]]))
}
else if(length(input$linetype_var) > 0){
p <- ggplot(data = data_prm_combined_plot_rename$data, aes(x = .data[[input$x_var]], y = .data[[input$y_var]], group = .data[[input$linetype_var]], linetype = .data[[input$linetype_var]]))
}
else{
p <- ggplot(data = data_prm_combined_plot_rename$data, aes(x = .data[[input$x_var]], y = .data[[input$y_var]]))
}
#add plot
p <- p +
theme(axis.title = element_text(size = as.numeric(input$font_size_axis_title)),
axis.text = element_text(size = as.numeric(input$font_size_axis_text)),
legend.title = element_blank(),
#legend.title = element_text(size = as.numeric(input$font_size_legend)),
legend.text = element_text(size = as.numeric(input$font_size_legend)),
strip.text = element_text(size = as.numeric(input$font_size_facet)),
plot.title = element_text(size = as.numeric(input$font_size_plot_title)),
legend.position = paste(input$legend_position),
legend.direction = paste(legend_direction()),
panel.background = element_rect(colour = "black", fill = "white"),
plot.background = element_rect(colour = NA, fill = "white"),
axis.line = element_line(colour="black",size=0.1),
axis.ticks = element_line(),
axis.title.x = element_text(vjust = -2.5, face = "bold"),
axis.title.y = element_text(vjust = +2.5, face="bold"),
legend.key = element_rect(colour = NA, fill = NA),
legend.key.size= unit(0.75, "cm"),
strip.background=element_rect(colour="#000000",fill=NA),
plot.margin=unit(c(10,5,5,5),"mm")
) +
scale_color_manual(values=custom_palette()) +
scale_shape_manual(values=custom_shape()) +
scale_linetype_manual(values = custom_linetype())+
guides(color = guide_legend(override.aes = list(size=3)))
#pretty scales for numeric variable
if(is.numeric(data_prm_combined_plot_rename$data[[input$x_var]])){
p <- p +
scale_x_continuous(breaks = breaks_pretty(), limits = c(as.numeric(input$x_var_range[1]),as.numeric(input$x_var_range[2])))
}
if(is.numeric(data_prm_combined_plot_rename$data[[input$y_var]])){
p <- p +
scale_y_continuous(breaks = breaks_pretty(), limits = c(as.numeric(input$y_var_range[1]),as.numeric(input$y_var_range[2])))
}
if(is.Date(data_prm_combined_plot_rename$data[[input$x_var]])){
p <- p +
scale_x_date(breaks = breaks_pretty())
}
if(is.Date(data_prm_combined_plot_rename$data[[input$y_var]])){
p <- p +
scale_y_date(breaks = breaks_pretty())
}
#x axis text angle
if(as.numeric(input$x_axis_label_angle) > 0){
p <- p + theme(axis.text.x = element_text(angle = as.numeric(input$x_axis_label_angle), hjust = 1, vjust = 1))
}
#select facet variable
if(length(input$facet_var) == 1){
p <- p + facet_wrap(~get(input$facet_var[1]))
} else if(length(input$facet_var) == 2){
p <- p + facet_grid(get(input$facet_var[2])~get(input$facet_var[1]))
} else {
p <- p
}
#select plotting elements (geom)
if("point" %in% input$plot_element){
p <- p + geom_point(size = as.numeric(input$point_size), alpha = as.numeric(input$point_transparency))
}
if("line" %in% input$plot_element){
p <- p + geom_line(size = as.numeric(input$line_size))
}
if("linear_trend_error" %in% input$plot_element){
p <- p + geom_smooth(method="lm", se = T, show.legend = FALSE, size = as.numeric(input$line_size))
}
if("linear_trend" %in% input$plot_element & !("linear_trend_error" %in% input$plot_element)){
p <- p + geom_smooth(method="lm", se = F, show.legend = FALSE, size = as.numeric(input$line_size))
}
if("loess_smooth_trend_error" %in% input$plot_element){
p <- p + geom_smooth(method="loess", se = T, show.legend = FALSE, size = as.numeric(input$line_size))
}
if("loess_smooth_trend" %in% input$plot_element & !("loess_smooth_trend_error" %in% input$plot_element)){
p <- p + geom_smooth(method="loess", se = F, show.legend = FALSE, size = as.numeric(input$line_size))
}
if("background_grid" %in% input$plot_element){
p <- p + theme(panel.grid.major = element_line(colour="#f0f0f0"),
panel.grid.minor = element_blank())
}else{
p <- p + theme(panel.grid.major = element_blank())
}
if(length(input$plot_element) == 0){
p <- p
}
#add custom text for axis label
if(nchar(input$y_var_label) > 0){
p <- p + labs(y = paste(input$y_var_label))
}
if(nchar(input$x_var_label) > 0){
p <- p + labs(x = paste(input$x_var_label))
}
if(nchar(input$title_label) > 0){
p <- p + labs(title = paste(input$title_label))
}
print(p)
})
})
#adjust default plot size according to facets
#select facet variable
observeEvent(input$facet_var, {
if(length(input$facet_var) == 1){
if(length(unique(data_prm_combined_plot_rename$data[[input$facet_var[1]]])) == 1){
updateTextInput(session, "export_plot_width", value = "19")
updateTextInput(session,"export_plot_height", value = "12")
}
if(length(unique(data_prm_combined_plot_rename$data[[input$facet_var[1]]])) == 2){
updateTextInput(session, "export_plot_width", value = "29")
updateTextInput(session,"export_plot_height", value = "12")
}
if(length(unique(data_prm_combined_plot_rename$data[[input$facet_var[1]]])) > 2){
updateTextInput(session, "export_plot_width", value = "39")
updateTextInput(session,"export_plot_height", value = "12")
}
if(length(unique(data_prm_combined_plot_rename$data[[input$facet_var[1]]])) > 3){
updateTextInput(session, "export_plot_width", value = "39")
updateTextInput(session,"export_plot_height", value = "23")
}
}
if(length(input$facet_var) == 2){
if(length(unique(data_prm_combined_plot_rename$data[[input$facet_var[1]]])) == 1){
updateTextInput(session,"export_plot_width", value = "19")
}
if(length(unique(data_prm_combined_plot_rename$data[[input$facet_var[1]]])) == 2){
updateTextInput(session,"export_plot_width", value = "29")
}
if(length(unique(data_prm_combined_plot_rename$data[[input$facet_var[1]]])) > 2){
updateTextInput(session,"export_plot_width", value = "39")
}
if(length(unique(data_prm_combined_plot_rename$data[[input$facet_var[2]]])) == 1){
updateTextInput(session,"export_plot_height", value = "12")
}
if(length(unique(data_prm_combined_plot_rename$data[[input$facet_var[2]]])) > 1){
updateTextInput(session,"export_plot_height", value = "23")
}
}
})
#render ggplot display in app
output$ggplot_plugin_display <- renderPlot({
ggplot_plugin()
},width=exprToFunction(as.numeric(input$export_plot_width)*36), height=exprToFunction(as.numeric(input$export_plot_height)*36))
#for downloading ggplot
output$ggplot_plugin_download <- downloadHandler(
filename = function() {paste0("plot.", input$export_plot_format)},
content = function(file) {
ggsave(file, plot = ggplot_plugin(), device = {{input$export_plot_format}} , width = as.numeric({{input$export_plot_width}}), height = as.numeric({{input$export_plot_height}}), units = "cm")
}
)
###### Analysis ####
###create reactive dataset for analyses (take from seasonal data)
data_prm_combined_analysis <- reactiveValues()
observe({data_prm_combined_analysis$data <- data_prm_combined$data})
###time period window analysis
#update window slider input for selecting year range to include in analysis, set min max according to data
observe({
req(input$upload_all_files)
year.start <- min(data_prm_combined_analysis$data[["Year1"]])
year.end <- max(data_prm_combined_analysis$data[["Year1"]])
updateSliderInput(inputId = "time_range", min = year.start, max = year.end, value = c(year.start, year.end))
})
#update window slider input for year, set min max according to data
observe({
req(input$upload_all_files)
year.range <- max(data_prm_combined_analysis$data[["Year1"]]) - min(data_prm_combined_analysis$data[["Year1"]])
updateSliderInput(inputId = "time_period", min = 1, max = year.range)
})
#update variable choice
observe({
choices <- setdiff(colnames(data_prm_combined_analysis$data), c("name","RunNr","Day1","Month1","Year1","DayN","MonthN","YearN","prm.file"))
choices <- setdiff(choices, colnames(upload_prm_combined_renamecol$data))
updateSelectizeInput(inputId = "time_period_variable", choices = sort(choices))
})
#update grouping choice
observe({
group.choices <- setdiff(colnames(data_prm_combined_analysis$data), colnames(upload_data_combined()))
updateSelectizeInput(inputId = "time_period_group", choices = sort(group.choices))
})
#calculate summary in time period selected
data_prm_combined_timeperiod <- reactive({
req(input$upload_all_files)
req(input$time_period_variable)
#cut time into windows
column.select <- c("time.window", input$time_period_variable, input$time_period_group)
column.group <- c(input$time_period_group, "time.window")
#calculate summary
data_prm_combined_analysis$data %>%
filter(Year1 >= input$time_range[1] & Year1 <= input$time_range[2]) %>%
mutate(time.window = cut(Year1,
unique(c(seq(min(Year1), max(Year1), input$time_period),min(Year1), max(Year1))),
include.lowest = TRUE, right = FALSE, dig.lab = 4)) %>%
mutate(time.window = str_replace_all(time.window,"\\[|\\)","")) %>%
separate(time.window, c("start", "end"), sep = ",") %>%
mutate(end = ifelse(str_detect(end, "\\]"), as.numeric(str_replace(end, "\\]",""))+1, end))%>%
mutate(time.window = paste0(start, "-", as.numeric(end)-1)) %>%
select(all_of(column.select)) %>%
group_by(across(all_of(column.group))) %>%
summarise(mean = mean(.data[[input$time_period_variable]]),
SD = sd(.data[[input$time_period_variable]]),
coef.of.variation = SD/mean,
n = n()) %>%
mutate(mean = format(signif(mean, digits = 3)),
SD = format(signif(SD, digits = 3)),
coef.of.variation = format(signif(coef.of.variation, digits = 3))
) %>%
rename_with(~paste0(input$time_period_variable, ".", .x), c(mean, SD, coef.of.variation))
})
#display table
output$data_prm_combined_timeperiod_display <- renderDataTable(data_prm_combined_timeperiod(), options = list(scrollX = TRUE))
#for downloading calculated dataset
output$download_data_prm_combined_timeperiod <- downloadHandler(
filename = "Aquacrop_time_window_analysis.tsv",
content = function(file) {
write_tsv(data_prm_combined_timeperiod(), file)
}
)
###stress, phenological stage analysis
#update grouping choice
observe({
group.choices <- setdiff(colnames(daily_data_prm_combined$data), colnames(upload_daily_data_combined()))
updateSelectizeInput(inputId = "stress_group", choices = sort(group.choices))
})
#calculate summary
daily_data_prm_combined_stress <- reactive({
req(input$upload_all_files)
#selecting variables
if(input$by_phenological == "yes"){
column.group <- c("Year", "Stage", "prm.file.name", input$stress_group)
column.select <- c("Year","Stage", "StExp", "StSto", "StSen", "StTr","prm.file.name", input$stress_group)
}else{
column.group <- c("Year", "prm.file.name", input$stress_group)
column.select <- c("Year", "StExp", "StSto", "StSen", "StTr","prm.file.name", input$stress_group)
}
#calculate summary
daily_data_prm_combined$data %>%
mutate(Stage = as.character(Stage)) %>%
mutate(Stage = case_when(
Stage == "0" ~ "0_before_after_cropping",
Stage == "1" ~ "1_sowing_transplant",
Stage == "2" ~ "2_vegetative",
Stage == "3" ~ "3_flowering",
Stage == "4" ~ "4_yield_ripening",
Stage == "-9" ~ "-9_senescence",
TRUE ~ Stage
)) %>%
select(all_of(column.select)) %>%
group_by(across(all_of(column.group))) %>%
summarise(StExp.duration.days = length(StExp[which(StExp >= as.numeric(input$StExp_threshold))]),
StSto.duration.days = length(StSto[which(StSto >= as.numeric(input$StSto_threshold))]),
StSen.duration.days = length(StSen[which(StSen >= as.numeric(input$StSen_threshold))]),
StTr.duration.days = length(StTr[which(StTr >= as.numeric(input$StTr_threshold))]),
StExp.duration.percent = length(StExp[which(StExp >= as.numeric(input$StExp_threshold))])/length(StExp[which(StExp >= 0)]),
StSto.duration.percent = length(StSto[which(StSto >= as.numeric(input$StSto_threshold))])/length(StSto[which(StSto >= 0)]),
StSen.duration.percent = length(StSen[which(StSen >= as.numeric(input$StSen_threshold))])/length(StSen[which(StSen >= 0)]),
StTr.duration.percent = length(StTr[which(StTr >= as.numeric(input$StTr_threshold))])/length(StTr[which(StTr >= 0)])
) %>%
mutate(StExp.duration.percent = format(signif(StExp.duration.percent*100, digits = 2)) %>% as.numeric(),
StSto.duration.percent = format(signif(StSto.duration.percent*100, digits = 2)) %>% as.numeric(),
StSen.duration.percent = format(signif(StSen.duration.percent*100, digits = 2)) %>% as.numeric(),
StTr.duration.percent = format(signif(StTr.duration.percent*100, digits = 2)) %>% as.numeric()
)
})
#display table
output$daily_data_prm_combined_stress_display <- renderDataTable(daily_data_prm_combined_stress(), options = list(scrollX = TRUE))
#for downloading calculated dataset
output$download_daily_data_prm_combined_stress <- downloadHandler(
filename = "Aquacrop_stress_analysis.tsv",
content = function(file) {
write_tsv(daily_data_prm_combined_stress(), file)
}
)
##append stress duration data to seasonal dataset for plotting and other analyses
observeEvent(input$append_stress_data_button, {
data_prm_combined_analysis$data <- left_join(data_prm_combined_analysis$data %>% select(all_of(setdiff(colnames(data_prm_combined_analysis$data),c("StExp.duration.days", "StSto.duration.days", "StSen.duration.days", "StTr.duration.days", "StExp.duration.percent", "StSto.duration.percent", "StSen.duration.percent", "StTr.duration.percent")))),
daily_data_prm_combined_stress() %>% select("prm.file.name", "Year", "StExp.duration.days", "StSto.duration.days", "StSen.duration.days", "StTr.duration.days", "StExp.duration.percent", "StSto.duration.percent", "StSen.duration.percent", "StTr.duration.percent"),
by = c("prm.file.name" = "prm.file.name", "Year1"="Year"))
updateSelectizeInput(inputId = "plot_mode", selected = "seasonal")
})
observeEvent(input$append_stress_data_button, {
req(data_prm_combined_plot_rename$data)
if(input$plot_mode == "seasonal"){
data_prm_combined_plot_rename$data  <- left_join(data_prm_combined_plot_rename$data %>% select(all_of(setdiff(colnames(data_prm_combined_plot_rename$data),c("StExp.duration.days", "StSto.duration.days", "StSen.duration.days", "StTr.duration.days", "StExp.duration.percent", "StSto.duration.percent", "StSen.duration.percent", "StTr.duration.percent")))),
daily_data_prm_combined_stress() %>% select("prm.file.name", "Year", "StExp.duration.days", "StSto.duration.days", "StSen.duration.days", "StTr.duration.days", "StExp.duration.percent", "StSto.duration.percent", "StSen.duration.percent", "StTr.duration.percent"),
by = c("prm.file.name" = "prm.file.name", "Year1"="Year"))
}
})
######regression
##select data mode daily or seasonal
data_mode_selected_regression <- reactive({
req(input$regression_mode)
req(input$upload_all_files)
if(input$regression_mode == "daily"){
#return data to use
daily_data_prm_combined$data
}else{
#return data to use
data_prm_combined_analysis$data
}
})
observe({
req(input$regression_mode)
req(input$upload_all_files)
if(input$regression_mode == "daily"){
#update choices for variables
axis.choices = unique(colnames(daily_data_prm_combined$data))
updateSelectInput(inputId = "regression_y_variable", choices = sort(axis.choices))
updateSelectInput(inputId = "regression_x_variable", choices = sort(axis.choices))
#update choices for grouping variable
group.choices <- setdiff(colnames(daily_data_prm_combined$data), colnames(upload_daily_data_combined()))
group.choices <- c(group.choices, "Stage")
updateSelectizeInput(inputId = "regression_group", choices = sort(group.choices))
}else{
#update choices for variables
axis.choices = unique(colnames(data_prm_combined_analysis$data))
updateSelectInput(inputId = "regression_y_variable", choices = sort(axis.choices))
updateSelectInput(inputId = "regression_x_variable", choices = sort(axis.choices))
#update choices for grouping variable
group.choices <- setdiff(colnames(data_prm_combined_analysis$data), colnames(upload_data_combined()))
updateSelectizeInput(inputId = "regression_group", choices = sort(group.choices))
}
})
#regression calculation
data_regression <- reactive({
req(input$regression_mode)
req(input$regression_y_variable)
req(input$regression_x_variable)
req(input$upload_all_files)
if(length(input$regression_group) > 0){
column.group <- input$regression_group
column.select <- c(input$regression_y_variable, input$regression_x_variable, input$regression_group)
}else{
column.group <- NULL
column.select <- c(input$regression_y_variable, input$regression_x_variable)
}
data_mode_selected_regression() %>%
select(all_of(column.select)) %>%
group_by(across(all_of(column.group))) %>%
nest() %>%
mutate(model = map(data, function(data){
mod <- lm(data = data, as.formula(paste0("`",input$regression_y_variable,"`","~","`",input$regression_x_variable,"`")))
r.squared <- glance(mod)[["r.squared"]] %>% signif(digits = 3) %>% format()
slope <- tidy(mod)[["estimate"]][[2]] %>% signif(digits = 3) %>% format()
p.value <- tidy(mod)[["p.value"]][[2]] %>% signif(digits = 3) %>% format()
summary <- data.frame(r.squared,slope,p.value)
})) %>%
select(-data) %>%
unnest(model)
})
#output datatable of the regression
output$regression_display <- renderDataTable(datatable(data_regression(),
options = list(scrollX = TRUE)))
#for downloading regresion data
output$download_regression <- downloadHandler(
filename = "Aquacrop_regression.tsv",
content = function(file) {
write_tsv(data_regression(), file)
}
)
}
# Run the application
shinyApp(ui = ui, server = server)
install.packages("reoxygen")
library(cavaR)
library(cavaR)
remote.data <- load_data(country = "Sudan", variable="tasmax", years.hist=1980:2000, years.proj=2050:2080,
path.to.data = "~/Databases/CORDEX-CORE/AFR-22", path.to.obs="~/Databases/W5E5")
library(cavaR)
remote.data <- load_data(country = "Sudan", variable="tasmax", years.hist=1995:2000, years.proj=2050:2060,
path.to.data = "CORDEX-CORE", path.to.obs="W5E5", domain="AFR-22", n.cores=9)
start <-  "CORDEX-"
domain <-  "AFR-22"
GCM= c("_MOHC-HadGEM2-ES_", "_MPI-M-MPI-ESM-MR_", "_NCC-NorESM1-M_")
forcing= c("historical", "rcp26", "rcp85")
RCM= c("_r1i1p1_ICTP-RegCM4-7_v0" )
files= purrr::map(forcing, ~ paste0(GCM, .x)) %>%
purrr::map(., ~ paste0(start, domain, .x, RCM))
library(magrittr)
files= purrr::map(forcing, ~ paste0(GCM, .x)) %>%
purrr::map(., ~ paste0(start, domain, .x, RCM))
if(method=="multiply") return(prod(x))
myfun <- function(x, method=c("add","multiply")){
if(!missing(method) & length(method)>1) stop("Only one 'method' allowed.")
method <- match.arg(method)
if(method=="add") return(sum(x))
if(method=="multiply") return(prod(x))
}
myfun(1:10, method = "ciao")
myfun <- function(x, method=c("add","multiply")){
if(!missing(method) & length(method)>1) stop("Only one 'method' allowed.")
#  method <- match.arg(method)
if(method=="add") return(sum(x))
if(method=="multiply") return(prod(x))
}
myfun(1:10, method = "ciao")
myfun <- function(x, method=c("add","multiply")){
if(!missing(method) & length(method)>1) stop("Only one 'method' allowed.")
method <- match.arg(method)
if(method=="add") return(sum(x))
if(method=="multiply") return(prod(x))
}
myfun(1:10, method = "ciao")
method=c("add","multiply")
method=c("add","multiply")
method <- match.arg(method)
myfun <- function(x, method=c("nested",1:10)){
if(!missing(method) & length(method)>1) stop("Only one 'method' allowed.")
method <- match.arg(method)
}
myfun(1:10, method = "ciao")
library(cavaR)
library(cavaR)
library(magrittr)
remote.data <- load_data(country = "Sudan", variable="tasmax", years.hist=1995:2000, years.proj=2050:2060,
path.to.data = "CORDEX-CORE", path.to.obs="W5E5", domain="AFR-22", n.cores="nested")
out <- remote.data %>%
projections(bias.correction = F, season = 1:12, uppert=NULL, lowert = NULL, consecutive = F)
cl4.object <- remote.data[[1]]$models_mbrs[[1]]
xmin <- if (is.null(cl4.object$xyCoords$lon))  min(cl4.object$xyCoords$x) else  min(cl4.object$xyCoords$lon[,1])
xmax <-  if (is.null(cl4.object$xyCoords$lon))  max(cl4.object$xyCoords$x) else  max(cl4.object$xyCoords$lon[,1])
ymin <-  if (is.null(cl4.object$xyCoords$lat))  min(cl4.object$xyCoords$y) else  min(cl4.object$xyCoords$lat[1,])
ymax <-  if (is.null(cl4.object$xyCoords$lat))  max(cl4.object$xyCoords$y) else  max(cl4.object$xyCoords$lat[1,])
xmin
xmax
ymin
ymax
min(cl4.object$xyCoords$lon[,1])
cl4.object$xyCoords$lon[,1]
cl4.object$xyCoords$lon
dim(cl4.object$Data)
dim(cl4.object$Data)
dim(cl4.object$xyCoords$lon)
remote.data[[1]]$models_mbrs[[1]]$xyCoords$lat
remote.data[[1]]$models_mbrs[[1]]$xyCoords$lat[,1]
xmin <- if (is.null(cl4.object$xyCoords$lon))  min(cl4.object$xyCoords$x) else  min(cl4.object$xyCoords$lon[1,])
xmax <-  if (is.null(cl4.object$xyCoords$lon))  max(cl4.object$xyCoords$x) else  max(cl4.object$xyCoords$lon[1,])
ymin <-  if (is.null(cl4.object$xyCoords$lat))  min(cl4.object$xyCoords$y) else  min(cl4.object$xyCoords$lat[,1])
ymax <-  if (is.null(cl4.object$xyCoords$lat))  max(cl4.object$xyCoords$y) else  max(cl4.object$xyCoords$lat[,1])
xmin
xmax
ymin
ymax
library(cavaR)
out <- remote.data %>%
projections(bias.correction = F, season = 1:12, uppert=NULL, lowert = NULL, consecutive = F)
out %>%
plotting(plot_titles = "N. days")
system.time( remote.data <- load_data(country = "Sudan", variable="tasmax", years.hist=1995:2000, years.proj=2050:2060,
path.to.data = "CORDEX-CORE", path.to.obs="W5E5", domain="AFR-22", n.cores="nested"))
library(cavaR)
knitr::opts_chunk$set(echo = TRUE)
knitr::include_graphics
knitr::opts_chunk$set(echo = TRUE)
knitr::include_graphics
library(cavaR)
local.data <- load_data(country = "Sudan", variable="tasmax", years.hist=1980:2000, years.proj=2050:2080,
path.to.data = "~/Databases/CORDEX-CORE/AFR-22", path.to.obs="~/Databases/W5E5", n.cores = 6)
local.data <- load_data(country = "Sudan", variable="tasmax", years.hist=1980:2000, years.proj=2050:2080,
path.to.data = "~/Databases/CORDEX-CORE/AFR-22", path.to.obs="~/Databases/W5E5", n.cores = "6")
library(cavaR)
range(remote.data[[1]]$models_mbrs[[1]]$Data)
library(cavaR)
library(cavaR)
knitr::opts_chunk$set(echo = TRUE)
knitr::include_graphics
library(cavaR)
local.data <- load_data(country = "Sudan", variable="tasmax", years.hist=1980:2000, years.proj=2050:2080,
path.to.data = "~/Databases/CORDEX-CORE/AFR-22", path.to.obs="~/Databases/W5E5", n.cores = "6")
library(cavaR)
